# This file is part of NIT ( http://www.nitlanguage.org ).
#
# Copyright 2008 Jean Privat <jean@pryen.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Compute and generate tables for classes and modules.
package compiling

import table_computation
import compiling_base
private import icode_generator
private import compiling_global
private import compiling_icode
private import analysis

redef class Program
	# The type of code generation to use
	readable writable var _output_format: String = "none"

	# Compile the program depending on the output format
	fun compile_prog
	do
		if output_format == "none" then
			# Nothing to do
		else
			# Optimize all iroutines
			with_each_iroutines !action(i, m) do i.optimize(m)

			if output_format == "C" then
				compile_prog_to_c
			else if output_format == "icode" then
				generate_icode_files
			end
		end
	end

	# Compile the program to C
	# Generate all files (_sep.[ch] or _glob.[ch]), the main file (_table.c) and the build file (_build.sh)
	# Then execute the build.sh
	fun compile_prog_to_c
	do
		var cprogram = new CProgram(self)

		cprogram.compdir.mkdir

		cprogram.files.add("$CLIBDIR/nit_main.c")
		cprogram.files.add("$CLIBDIR/gc.c")
		cprogram.files.add("$CLIBDIR/gc_static_objects_list.c")

		tc.info("Generating C code",1)
		for m in main_module.mhe.greaters_and_self do m.compile_separate_module(cprogram)

		tc.info("Generating main, tables and makefile ...",1)
		compile_main(cprogram)

		cprogram.generate_build_file

		if not tc.no_cc then cprogram.run_c_compiler
	end

	# Compile the main file
	private fun compile_main(cprogram: CProgram)
	do
		var v = new CompilerVisitor(main_module, cprogram)
		v.add_decl("#include <nit_common.h>")
		compile_tables_to_c(v)
		compile_main_part(v)
		var filename = "{cprogram.compdir}/{main_module.cname}._tables.c"
		cprogram.files.add(filename)
		var f = new OFStream.open(filename)
		f.write("/* This C file is generated by NIT to compile program {main_module.cname}. */\n")
		for m in main_module.mhe.greaters_and_self do
			f.write("#include \"{cprogram.module_header_name(m)}\"\n")
		end
		v.header_writer.write_to_stream(f)
		v.writer.write_to_stream(f)
		f.close
	end
end

redef class MMModule
	# Compile the sep or glob files (of the current module only)
	fun compile_separate_module(cprogram: CProgram)
	do
		var tc = cprogram.program.tc
		tc.info("Generating C code for module: {full_name}",2)
		var v = new CompilerVisitor(self, cprogram)
		v.add_decl("#include <nit_common.h>")

		if is_extern_hybrid then
			# adds reference to frontier files
			# if module uses the native interface
			var nitni_header_name = "{name}._nitni.h"
			v.add_decl("#include \"{nitni_header_name}\"")
			var nitni_body_name = "{name}._nitni.c"
			cprogram.files.add( "{cprogram.compdir}/{nitni_body_name}" )

			# add reference to extern implementation
			var native_name = location.file.filename.strip_extension(".nit")
			var native_body = native_name + ".nit.c"
			if native_body.file_exists then
				cprogram.files.add(native_body)
			else # try old style filename
				native_body = native_name + "_nit.c"
				if native_body.file_exists then	cprogram.files.add(native_body)
			end
			if uses_ffi then
				var ffi_header_name = "{cname}._ffi.h"
				v.add_decl("#include \"{ffi_header_name}\"")
				var ffi_body_name = "{cname}._ffi.c"
				cprogram.files.add( "{cprogram.compdir}/{ffi_body_name}" )
			end
		end

		declare_class_tables_to_c(v)
		compile_mod_to_c(v)

		var hfilename = cprogram.module_header_name(self)
		var f = new OFStream.open("{cprogram.compdir}/{hfilename}")
		f.write("/* This C header file is generated by NIT to compile modules and programs that requires {full_name}. */\n")
		f.write("#ifndef {cname}{cprogram.get_file_ending}\n")
		f.write("#define {cname}{cprogram.get_file_ending}\n")
		for m in mhe.direct_greaters do f.write("#include \"{cprogram.module_header_name(m)}\"\n")
		v.header_writer.write_to_stream(f)
		f.write("#endif\n")
		f.close

		var cfilename = "{cprogram.compdir}/{cname}.{cprogram.get_file_ending}.c"
		cprogram.files.add(cfilename)
		f = new OFStream.open("{cfilename}")
		f.write("/* This C file is generated by NIT to compile module {cname}. */\n")
		f.write("#include \"{hfilename}\"\n")
		v.top_writer.write_to_stream(f)
		f.close
	end
end

